#!/usr/bin/env python3
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

from __future__ import print_function

import sys
import time

from socket import error

from threading import Thread

from twisted.python import log
from twisted.internet import reactor, ssl
from twisted.internet.error import CannotListenError, ReactorNotRunning
from distutils.version import LooseVersion
import autobahn #to check version
from autobahn.twisted.websocket import WebSocketServerFactory, connectWS
from autobahn.websocket.compress import (PerMessageDeflateOffer,
                                         PerMessageDeflateOfferAccept)

import rclpy
from rclpy.node import Node
from rclpy.parameter import Parameter
from rclpy.qos import QoSProfile, QoSDurabilityPolicy
from std_msgs.msg import Int32

# from rosbridge_server import RosbridgeWebSocket, ClientManager

from rosbridge_library.capabilities.advertise import Advertise
from rosbridge_library.capabilities.publish import Publish
from rosbridge_library.capabilities.subscribe import Subscribe
from rosbridge_library.capabilities.advertise_service import AdvertiseService
from rosbridge_library.capabilities.unadvertise_service import UnadvertiseService
from rosbridge_library.capabilities.call_service import CallService

from rosbridge_client import RosbridgeWebSocketClientProtocol, RosbridgeWebSocketClientFactory


# def start_hook():
#     IOLoop.instance().start()

# def shutdown_hook():
#     IOLoop.instance().stop()


class RosbridgeWebsocketClientNode(Node):
    def __init__(self):
        super().__init__('rosbridge_websocket_client')

        RosbridgeWebSocketClientProtocol.node_handle = self

        ##################################################
        # Parameter handling                             #
        ##################################################
        retry_startup_delay = self.declare_parameter('retry_startup_delay', 2.0).value  # seconds.

        use_compression = self.declare_parameter('use_compression', False).value
        jwt_token = self.declare_parameter('jwt_token').value

        # RosbridgeWebSocket.use_compression = self.declare_parameter(
        #     'use_compression', False).value

        # get RosbridgeProtocol parameters
        RosbridgeWebSocketClientProtocol.fragment_timeout = self.declare_parameter(
            'fragment_timeout', RosbridgeWebSocketClientProtocol.fragment_timeout).value

        RosbridgeWebSocketClientProtocol.delay_between_messages = self.declare_parameter(
            'delay_between_messages', RosbridgeWebSocketClientProtocol.delay_between_messages).value

        RosbridgeWebSocketClientProtocol.max_message_size = self.declare_parameter(
            'max_message_size', RosbridgeWebSocketClientProtocol.max_message_size).value

        RosbridgeWebSocketClientProtocol.unregister_timeout = self.declare_parameter(
            'unregister_timeout', RosbridgeWebSocketClientProtocol.unregister_timeout).value

        bson_only_mode = self.declare_parameter('bson_only_mode', False).value

        if RosbridgeWebSocketClientProtocol.max_message_size == "None":
            RosbridgeWebSocketClientProtocol.max_message_size = None

        ping_interval = float(self.declare_parameter('websocket_ping_interval', 0).value)
        ping_timeout = float(self.declare_parameter('websocket_ping_timeout', 30).value)
        null_origin = self.declare_parameter('websocket_null_origin', True).value #default to original behaviour

        # SSL options
        certfile = self.declare_parameter('certfile').value
        keyfile = self.declare_parameter('keyfile').value
       
        # if authentication should be used
        RosbridgeWebSocketClientProtocol.authenticate = self.declare_parameter('authenticate', False).value

        port = self.declare_parameter('port', 9090).value

        address = self.declare_parameter('address', '').value

        # Publisher for number of connected clients
        # QoS profile with transient local durability (latched topic in ROS 1).
        client_count_qos_profile = QoSProfile(
            depth=10,
            durability=QoSDurabilityPolicy.TRANSIENT_LOCAL
        )

        # Get the glob strings and parse them as arrays.
        topics_glob = self.declare_parameter('topics_glob', '').value

        services_glob = self.declare_parameter('services_glob', '').value

        params_glob = self.declare_parameter('params_glob', '').value

        RosbridgeWebSocketClientProtocol.topics_glob = [
            element.strip().strip("'")
            for element in topics_glob[1:-1].split(',')
            if len(element.strip().strip("'")) > 0]
        RosbridgeWebSocketClientProtocol.services_glob = [
            element.strip().strip("'")
            for element in services_glob[1:-1].split(',')
            if len(element.strip().strip("'")) > 0]
        RosbridgeWebSocketClientProtocol.params_glob = [
            element.strip().strip("'")
            for element in params_glob[1:-1].split(',')
            if len(element.strip().strip("'")) > 0]

        if "--port" in sys.argv:
            idx = sys.argv.index("--port")+1
            if idx < len(sys.argv):
                port = int(sys.argv[idx])
            else:
                print("--port argument provided without a value.")
                sys.exit(-1)

        if "--address" in sys.argv:
            idx = sys.argv.index("--address")+1
            if idx < len(sys.argv):
                address = int(sys.argv[idx])
            else:
                print("--address argument provided without a value.")
                sys.exit(-1)

        if "--retry_startup_delay" in sys.argv:
            idx = sys.argv.index("--retry_startup_delay") + 1
            if idx < len(sys.argv):
                retry_startup_delay = int(sys.argv[idx])
            else:
                print("--retry_startup_delay argument provided without a value.")
                sys.exit(-1)

        if "--fragment_timeout" in sys.argv:
            idx = sys.argv.index("--fragment_timeout") + 1
            if idx < len(sys.argv):
                RosbridgeWebSocketClientProtocol.fragment_timeout = int(sys.argv[idx])
            else:
                print("--fragment_timeout argument provided without a value.")
                sys.exit(-1)

        if "--delay_between_messages" in sys.argv:
            idx = sys.argv.index("--delay_between_messages") + 1
            if idx < len(sys.argv):
                RosbridgeWebSocketClientProtocol.delay_between_messages = float(sys.argv[idx])
            else:
                print("--delay_between_messages argument provided without a value.")
                sys.exit(-1)

        if "--max_message_size" in sys.argv:
            idx = sys.argv.index("--max_message_size") + 1
            if idx < len(sys.argv):
                value = sys.argv[idx]
                if value == "None":
                    RosbridgeWebSocketClientProtocol.max_message_size = None
                else:
                    RosbridgeWebSocketClientProtocol.max_message_size = int(value)
            else:
                print("--max_message_size argument provided without a value. (can be None or <Integer>)")
                sys.exit(-1)

        if "--unregister_timeout" in sys.argv:
            idx = sys.argv.index("--unregister_timeout") + 1
            if idx < len(sys.argv):
                unregister_timeout = float(sys.argv[idx])
            else:
                print("--unregister_timeout argument provided without a value.")
                sys.exit(-1)

        if "--topics_glob" in sys.argv:
            idx = sys.argv.index("--topics_glob") + 1
            if idx < len(sys.argv):
                value = sys.argv[idx]
                if value == "None":
                    RosbridgeWebSocketClientProtocol.topics_glob = []
                else:
                    RosbridgeWebSocketClientProtocol.topics_glob = [element.strip().strip("'") for element in value[1:-1].split(',')]
            else:
                print("--topics_glob argument provided without a value. (can be None or a list)")
                sys.exit(-1)

        if "--services_glob" in sys.argv:
            idx = sys.argv.index("--services_glob") + 1
            if idx < len(sys.argv):
                value = sys.argv[idx]
                if value == "None":
                    RosbridgeWebSocketClientProtocol.services_glob = []
                else:
                    RosbridgeWebSocketClientProtocol.services_glob = [element.strip().strip("'") for element in value[1:-1].split(',')]
            else:
                print("--services_glob argument provided without a value. (can be None or a list)")
                sys.exit(-1)

        if "--params_glob" in sys.argv:
            idx = sys.argv.index("--params_glob") + 1
            if idx < len(sys.argv):
                value = sys.argv[idx]
                if value == "None":
                    RosbridgeWebSocketClientProtocol.params_glob = []
                else:
                    RosbridgeWebSocketClientProtocol.params_glob = [element.strip().strip("'") for element in value[1:-1].split(',')]
            else:
                print("--params_glob argument provided without a value. (can be None or a list)")
                sys.exit(-1)

        if ("--bson_only_mode" in sys.argv) or bson_only_mode:
            RosbridgeWebSocketClientProtocol.bson_only_mode = bson_only_mode

        if "--websocket_ping_interval" in sys.argv:
            idx = sys.argv.index("--websocket_ping_interval") + 1
            if idx < len(sys.argv):
                ping_interval = float(sys.argv[idx])
            else:
                print("--websocket_ping_interval argument provided without a value.")
                sys.exit(-1)

        if "--websocket_ping_timeout" in sys.argv:
            idx = sys.argv.index("--websocket_ping_timeout") + 1
            if idx < len(sys.argv):
                ping_timeout = float(sys.argv[idx])
            else:
                print("--websocket_ping_timeout argument provided without a value.")
                sys.exit(-1)

        if "--websocket_external_port" in sys.argv:
            idx = sys.argv.index("--websocket_external_port") + 1
            if idx < len(sys.argv):
                external_port = int(sys.argv[idx])
            else:
                print("--websocket_external_port argument provided without a value.")
                sys.exit(-1)

        # To be able to access the list of topics and services, you must be able to access the rosapi services.
        if RosbridgeWebSocketClientProtocol.services_glob:
            RosbridgeWebSocketClientProtocol.services_glob.append("/rosapi/*")

        Subscribe.topics_glob = RosbridgeWebSocketClientProtocol.topics_glob
        Advertise.topics_glob = RosbridgeWebSocketClientProtocol.topics_glob
        Publish.topics_glob = RosbridgeWebSocketClientProtocol.topics_glob
        AdvertiseService.services_glob = RosbridgeWebSocketClientProtocol.services_glob
        UnadvertiseService.services_glob = RosbridgeWebSocketClientProtocol.services_glob
        CallService.services_glob = RosbridgeWebSocketClientProtocol.services_glob

        ##################################################
        # Done with parameter handling                   #
        ##################################################

        # application = Application([(r"/", RosbridgeWebSocketClientProtocol), (r"", RosbridgeWebSocketClientProtocol)], **tornado_settings)
        server_address = 'ws://www.uniqrobot.com:18888/robot/c0b5d7943d7b' #address + ':' + str(port)  #"ws://localhost:9090")

        def handle_compression_offers(offers):
            if not use_compression:
                return
            for offer in offers:
                if isinstance(offer, PerMessageDeflateOffer):
                    return PerMessageDeflateOfferAccept(offer)

        # if jwt_token:
        #     headers = {'Authorization': 'Bearer {}'.format(jwt_token)}
        headers = {'Authorization': 'Bearer {}'.format(jwt_token)}

        factory = RosbridgeWebSocketClientFactory(server_address) #, headers=headers)

        # SSL client context: default
        ##
        if factory.isSecure:
            print('Using client context factory')
            context_factory = ssl.ClientContextFactory()
        else:
            context_factory = None

        # https://github.com/crossbario/autobahn-python/commit/2ef13a6804054de74eb36455b58a64a3c701f889
        if LooseVersion(autobahn.__version__) < LooseVersion("0.15.0"):
            factory.setProtocolOptions(
                perMessageCompressionAccept=handle_compression_offers,
                autoPingInterval=ping_interval,
                autoPingTimeout=ping_timeout,
            )
        else:
            factory.setProtocolOptions(
                perMessageCompressionAccept=handle_compression_offers,
                autoPingInterval=ping_interval,
                autoPingTimeout=ping_timeout,
                # allowNullOrigin=null_origin,  #此处会报错
            )

        connectWS(factory, context_factory)
        self.get_logger().info('Rosbridge WebSocket client started at {}'.format(server_address))
    #     connected = False
    #     ws = None
    #     while not connected and self.context.ok():
    #         try:
    #             if certfile is not None and keyfile is not None:
    #                 ws = RosbridgeWebSocketClientProtocol(
    #                 server_address,
    #                 ssl_options={
    #                     "certfile": certfile,
    #                     "keyfile": keyfile
    #                 })
    #                 ws.connect()
    #             else:
    #                 ws = RosbridgeWebSocketClientProtocol(server_address)
    #                 ws.open()
    #                 ws.connect()
    #             self.get_logger().info("Rosbridge WebSocket connected on {}".format(server_address))
    #             connected = True
    #         except error as e:
    #             self.get_logger().warn(
    #                 "Unable to access server: {} "
    #                 "Retrying in {}s.".format(e, retry_startup_delay))
    #             time.sleep(retry_startup_delay)
   
    # def __del__(self):#当程序结束时运行
    #     ws.close()

def main(args=None):
    if args is None:
        args = sys.argv

    rclpy.init(args=args)
    rosbridge_websocket_client_node = RosbridgeWebsocketClientNode()

    # spin_callback = PeriodicCallback(lambda: rclpy.spin_once(rosbridge_websocket_node, timeout_sec=0.01), 1)
    # spin_callback.start()
    # start_hook()
    # rate = rosbridge_websocket_client_node.create_rate(1)
    try:
        # while rclpy.ok():
        #     rclpy.spin_once(rosbridge_websocket_client_node, timeout_sec=0.01)
        #     rate.sleep()
        rclpy.spin(rosbridge_websocket_client_node)
    except KeyboardInterrupt:
        pass

    rosbridge_websocket_client_node.destroy_node()
    rclpy.shutdown()
    # shutdown_hook()  # shutdown hook to stop the server

if __name__ == '__main__':
    main()
